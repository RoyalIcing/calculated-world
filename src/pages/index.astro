---
import { Code } from "astro/components";
import { wasmInstantiate } from "../wasm/wasmInstantiate";
import { joinBodyChunks } from "../wasm/wasmBodyChunks";

const collectedPublicURL = new URL(
  "https://storage.googleapis.com/collected-public/"
);
const baseWasmURL = new URL("sha256/application/wasm/", collectedPublicURL);
const counterHTMLWasm = await wasmInstantiate(
  new URL(
    "a8e931832cc7dce187d7234237f6cfef13e9fa523ab4101d3cec7bfb66e905c1.wasm",
    baseWasmURL
  ).href
);
const counterHTML = joinBodyChunks(
  counterHTMLWasm.instance.exports,
  counterHTMLWasm.memory
);

const initialSVGGlobals = { color_hex: 0x22dd44ff };
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Calculated.World</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />

    <script src="../custom-elements/wasm-html.js"></script>
  </head>
  <body>
    <main class="prose lg:prose-xl max-w-2xl mx-auto px-3 pt-16 pb-16">
      <h1 class="">
        <span class="text-sky-600">Calculated</span><span
          class="inline-block text-sky-400 animate-bounce"
          >&VeryThinSpace;<span class="inline-block relative"
            >.<span
              class="absolute top-0 left-0 font-black text-pink-400 animate-pulse"
              >.</span
            ></span
          >&VeryThinSpace;</span
        ><span class="text-pink-600">World</span>
      </h1>
      <p class="text-lg lg:text-2xl">
        The exact same WebAssembly downloaded on-demand running at the <span
          class="text-sky-600">edge</span
        >
        <em>and</em> in the <span class="text-pink-600">browser</span>. Made by <a
          href="https://icing.space/">Patrick Smith</a
        >.
      </p>
      <p>
        For decades CDNs have reliably served static content close to users. It
        would be great if they could run code, and that’s what the edge brings.
      </p>
      <!--<p>But deploying to the cloud requires understanding writing code and knowing, well, how to deploy.</p>-->
      <p>
        But wouldn’t it be great if adding new code was as easy as uploading an
        image? Sounds like a security hole waiting to go wrong right? <strong
          >WebAssembly</strong
        > allows code to be run safely in a sandbox. And the same WebAssembly can
        run on a server, in a browser, or even on device like a phone.
      </p>
      <p>
        The dream of universal code doesn’t have to be only by using JavaScript.
        We can have a new standard library, one that runs in every popular
        programming language, that is consistent across all environments and
        *-ends, and can be downloaded on demand.
      </p>

      <hr />

      <h2>Static HTML</h2>
      <template data-get-tailwind-to-generate-these-classes>
        <output class="flex p-4 bg-gray-800">0</output>
        <button
          data-action="increment"
          class="mt-4 inline-block py-1 px-4 bg-white text-black rounded"
          >Increment</button
        >
      </template>
      <ul>
        <li>
          <a
            href="/collected-public/wasm-static-html/a8e931832cc7dce187d7234237f6cfef13e9fa523ab4101d3cec7bfb66e905c1"
            >Counter</a
          >
          <p>
            A {counterHTMLWasm.moduleByteLength} byte wasm module renders this initial
            HTML on the server:
          </p>
          <div class="border-2 mt-4 pb-3 text-white">
            <Fragment set:html={counterHTML} />
          </div>
          <Code code={counterHTML} lang="html" />
        </li>
      </ul>
      <h2>Dynamic HTML (click on things)</h2>
      <ul>
        <li>
          <a
            href="/collected-public/wasm-dynamic-html/a8e931832cc7dce187d7234237f6cfef13e9fa523ab4101d3cec7bfb66e905c1"
            >Interactive Counter</a
          >
          <p>
            The same {counterHTMLWasm.moduleByteLength} byte wasm module renders
            initial HTML on the server, then the same wasm module is loaded by your browser where a <code>click</code> event listener is attached,
            which calls the <code>increment()</code> function exported from wasm, changing its internal state and re-rendering the HTML. Click to see!
          </p>
          <div class="border-2 mt-4 pb-3 text-white">
            <wasm-html
              data-url="/collected-public/wasm/a8e931832cc7dce187d7234237f6cfef13e9fa523ab4101d3cec7bfb66e905c1"
            >
              <Fragment set:html={counterHTML} />
            </wasm-html>
          </div>
          <Code
            code={`<wasm-html data-url="/collected-public/wasm/a8e931832cc7dce187d7234237f6cfef13e9fa523ab4101d3cec7bfb66e905c1">\n` +
              counterHTML.replaceAll(/^/gm, "  ") +
              "\n</wasm-html>"}
            lang="html"
          />
        </li>
      </ul>

	  <hr>

      <h2>SVG</h2>
      <a
        href="/collected-public/wasm-svg/a6e388fd5d780de90144044066d2eeb889c1f930c85b1fff0a6b530fad391f20"
        class="block hover:bg-sky-100"
      >
        <figure>
          <img
            src="/collected-public/wasm-svg/a6e388fd5d780de90144044066d2eeb889c1f930c85b1fff0a6b530fad391f20"
            alt="Black Square"
          />
          <figcaption>Black Square rendered at the edge</figcaption>
        </figure>
      </a>
      <a
        href="/collected-public/wasm-svg/a6e388fd5d780de90144044066d2eeb889c1f930c85b1fff0a6b530fad391f20?global.color_hex=0x2299eeff"
        class="block hover:bg-sky-100"
      >
        <figure>
          <img
            src="/collected-public/wasm-svg/a6e388fd5d780de90144044066d2eeb889c1f930c85b1fff0a6b530fad391f20?global.color_hex=0x2299eeff"
            alt="Black Square"
          />
          <figcaption>Blue Square rendered at the end</figcaption>
        </figure>
      </a>
      <a
        href="/collected-public/wasm-svg/a6e388fd5d780de90144044066d2eeb889c1f930c85b1fff0a6b530fad391f20?global.color_hex=0x2299ee77"
        class="block hover:bg-sky-100"
      >
        <figure>
          <img
            src="/collected-public/wasm-svg/a6e388fd5d780de90144044066d2eeb889c1f930c85b1fff0a6b530fad391f20?global.color_hex=0x2299ee77"
            alt="Black Square"
          />
          <figcaption>Transparent Blue Square rendered at the edge</figcaption>
        </figure>
      </a>
      <form name="svg-rect">
        <wasm-html
          data-url="/collected-public/wasm/a6e388fd5d780de90144044066d2eeb889c1f930c85b1fff0a6b530fad391f20"
          globals={JSON.stringify(initialSVGGlobals)}></wasm-html>
        <legend class="mt-1 mb-1 font-medium"
          >Your color choice rendered in the browser</legend
        >
        <label for="global_color_hex">
          Edit the hex color (RGBA):
          <input
            name="color_hex"
            type="text"
            id="global_color_hex"
            value="0x22dd44ff"
          />
        </label>
      </form>
      <script>
        const form = document.forms.namedItem("svg-rect")!;
        const wasmHTMLEl = form.querySelector("wasm-html") as HTMLElement;
        form.addEventListener("input", () => {
          const values = new FormData(form);
          const colorHex = parseInt(String(values.get("color_hex")));
          if (Number.isNaN(colorHex)) {
            return;
          }

          wasmHTMLEl.setAttribute(
            "globals",
            JSON.stringify({ color_hex: colorHex })
          );
        });
      </script>

      <hr />

      <h2>How does it work?</h2>
      <figure>
        <img src="/architecture.png" alt="" />
        <figcaption>
          Rendering HTML on the edge and in the browser. It starts from an
          object store (like S3) holding an example abc.wasm file, loaded by the
          edge server which renders the initial HTML sent to the user’s browser,
          which then loads an instance of the same abc.wasm, adds event handlers
          which are forwarded to the wasm instance, and then re-renders the
          HTML.
        </figcaption>
      </figure>

      <p>
        This site you fine viewer are looking at is authored using Astro in
        server mode, uses Deno Deploy for edge hosting, Google Cloud Storage to
        store .wasm files, and custom elements written in a handful of
        JavaScript.
      </p>
      <p>
        But this approach is tied to none of these. It could easily work as well
        in S3, Next.js running on Node.js.
      </p>
    </main>

    <footer role="contentinfo" class="prose max-w-2xl mx-auto px-3 pt-16 pb-16">
      <p>© 2023 Royal Icing Pty Ltd</p>
      <p>
        <a href="https://github.com/cool-calm/calculated-world"
          >View source on GitHub</a
        >
      </p>
    </footer>
  </body>
</html>
